<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>snpBMA: a package for details genetic association analysis of densely typed genetic regions</title>
<!-- 2013-06-10 Mon 17:01 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="author" content="Chris Wallace"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">snpBMA: a package for details genetic association analysis of densely typed genetic regions</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Bayesian Model Averaging and the BMA package</a></li>
<li><a href="#sec-2">2. Priors</a></li>
<li><a href="#sec-3">3. Simulate some data</a></li>
<li><a href="#sec-4">4. Using BMA to identify the causal variants</a></li>
<li><a href="#sec-5">5. A full BMA analysis using SNP tagging to quickly cover the model space</a>
<ul>
<li><a href="#sec-5-1">5.1. Visualizing the results</a></li>
<li><a href="#sec-5-2">5.2. Add back in the tagged SNPs</a></li>
<li><a href="#sec-5-3">5.3. Speedup 2: excluding SNPs with low single SNP support</a></li>
<li><a href="#sec-5-4">5.4. Excluding unlikely models</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Automating the analysis</a></li>
</ul>
</div>
</div>
<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{snpBMA analysis}
-->

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Bayesian Model Averaging and the BMA package</h2>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Priors</h2>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Simulate some data</h2>
<div class="outline-text-2" id="text-3">
<p>
We start with using some sample data from the snpStats package
including 20 SNPs, and simulating a quantitative trait that depends
on 3 causal SNPs.
</p>

<!--begin.rcode 
library(snpStats)
data(for.exercise, package="snpStats")
X <- snps.10[,11:30]
n <- nrow(X)
set.seed(12346)
Y <- rnorm(n,mean=as.numeric(X[,1]))*sqrt(0.1) +
  rnorm(n,mean=as.numeric(X[,5]))*sqrt(0.1) +
  rnorm(n,mean=as.numeric(X[,11]))*sqrt(0.1) +
  rnorm(n)*sqrt(0.7)
(causal <- colnames(X)[c(1,5,11)])
end.rcode-->

<p>
<code>X</code> contains some missing genotypes, but no SNPs with such a low call
rate we would worry in a large study.  Still, the rest of the analysis
is easier to interpret for the purposes of a vignette if we fill in
the missing values.
</p>

<!--begin.rcode 
summary(X)
X <- impute.missing(X)
end.rcode-->

<p>
Looking at the LD, we see this is a region in which D' (above the
diagonal) is very high, whilst \(r^2\) can be high between some SNPs,
and with moderately strong \(r^2 \simeq 0.7\) between two of our causal
SNPs:
</p>
<!--begin.rcode fig=TRUE
ld <- show.ld(X=X)
end.rcode-->
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Using BMA to identify the causal variants</h2>
<div class="outline-text-2" id="text-4">
<p>
Bayesian model averaging approaches can be slow when the number of
SNPs is very large, as the number of models grows rapidly.  The
simulated data are deliberately small here, so that you can compare
the effect of the different ways we tackle this, which fall into three
categories: 
</p>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> A full BMA analysis using SNP tagging to quickly cover the model space</h2>
<div class="outline-text-2" id="text-5">
<p>
First, we aim to cover the model space more rapidly by focusing on a
tagging subset of SNPs, then expand to include the tagged SNPs only in
the neighbourhood of supported models.  Tags can be selected using the
<code>tag</code> function, where <code>tag.threshold</code> sets the \(r^2\) threshold used to
group SNPs.  This function makes use of <code>hclust</code> to do the grouping.
We can see that not all of our causal SNPs will be analysed directly,
but some through tags.
</p>

<!--begin.rcode 
tags <- tag(X, tag.threshold=0.8)
tags[causal]
end.rcode-->

<p>
Now we can consider sets of models, fixing the number of SNPs each
time.  
</p>

<!--begin.rcode 
## make a snpBMAdata set
data <- make.data(X, Y,tags=tags,family="gaussian")

## Calculate Bayes Factors for all one SNP models
bma.1 <- bma.nsnps(data, nsnps=1)

## Summarise the SNPs with greatest support
head(ss1 <- snp.summary(bma.1))
end.rcode-->

<p>
Although the <code>bma.nsnps()</code> function works for any
number of SNPs, it can be simpler to think of growing your BMA models
from a parent generation (here, all possible one SNP models) to a
child generation (here, all possible two SNP models).  
</p>

<!--begin.rcode 
bma.2 <- bma.grow(data=data, bma=bma.1)
bma.3 <- bma.grow(data=data, bma=bma.2)
bma.4 <- bma.grow(data=data, bma=bma.3)
end.rcode-->
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Visualizing the results</h3>
<div class="outline-text-3" id="text-5-1">
<p>
It can be nice to visualize the support across these generations of
models graphically.  So far, we have assumed each model within a
generation has an equal prior, which seems reasonable in the absence
of specific information about the likely impact of each SNP.
However, it doesn't seem reasonable that all models, regardless of
the number of SNPs, should have equal priors.  Models with smaller
numbers of SNPs should be favoured.  We can implement this by
specifying a prior for the number of SNPs in a model.  <code>snpBMA</code> has
two functions to do this, or you can just create your own numeric vector.
</p>

<!--begin.rcode 
## assume a binomial prior for the number of SNPs with expectation of 3 causal SNPs
## ie exactly the scenario simulated!
priors <- prior.binomial(1:10, n=ncol(X), expected=3)
end.rcode-->

<p>
See the help for <code>prior.betabinomial</code> to understand the other
function available, and the difference to a binomial prior.
</p>

<!--begin.rcode fig=TRUE
## create a graph of BMA results so far
results <- stack(bma.1,bma.2,bma.3,bma.4)
 g<-graphBMA(bma.list=results, priors)

## g is an igraph, so you can do all the usual stuff with it:
g

## visualize
graphView(g)
end.rcode-->

<p>
This shows the models according to posterior probabilities <b>across the
model space visited</b>.  One model stands out, with SNPs 0, 1 and 5.
These are 0-based numeric indices of the SNPs included, and we can
identify these SNPs using:
</p>

<!--begin.rcode 
snps0(bma.3)[ as.character(c(0,1,5)) ]
end.rcode-->

<p>
but it can be easier just write the top models to screen
</p>
<!--begin.rcode 
top.models(results, priors)
end.rcode-->
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Add back in the tagged SNPs</h3>
<div class="outline-text-3" id="text-5-2">
<p>
We used tagging to span the space quickly.  Once we have found our
favoured models, it makes sense to see how the tagged SNPs in LD with
SNPs in those models change things.  There are a couple of subtleties
here to be aware of however:
</p>

<ol class="org-ol">
<li>the X matrix must be of full rank, which means a small amount of
tagging may always be necessary, say at r<sup>2</sup>=0.99
</li>
<li>when two SNPs are in strong LD, fitting both in the model can make
the model uninterpretable.  With snpBMA you can group SNPs so that
at most one of each group is included in any single model.  The
default grouping threshold is r<sup>2</sup>=0.8, but the optimal value will
depend on your data: with many subjects a higher threshold may be
appropriate, as the SNPs become statistically distinguishable.
</li>
</ol>

<!--begin.rcode 
## First, tag at r2=0.99
tags.99 <- tag(X, 0.99)

## group remaining snps at r2=0.8, using the first set of tags above as indices
groups <- group.tags(tags, keep=tags.99)
length(groups)
data.99 <- make.data(X, Y, tags=tags.99, family="guassian")
end.rcode-->

<p>
Now we decide which tag SNP groups we would like to "expand".  We
choose any SNPs in the top three models, after which the posterior
probabilities appear to tail off:
</p>

<!--begin.rcode 
top.models(results, priors)
expand.snps <- top.snps(results, priors, nmodels=3)
end.rcode-->

<p>
Now we can refit all models including these tagged SNPs in their
groups:
</p>
<!--begin.rcode 
bma.e1 <- bma.expand(data.99, bma.1, groups=groups[expand.snps])
bma.e2 <- bma.expand(data.99, bma.2, groups=groups[expand.snps])
bma.e3 <- bma.expand(data.99, bma.3, groups=groups[expand.snps])
bma.e4 <- bma.expand(data.99, bma.4, groups=groups[expand.snps])
end.rcode-->

<p>
You can see the model space grows much more quickly.  But the end
result is not dissimilar:
</p>

<!--begin.rcode fig=TRUE
## create a graph of BMA results so far
expand.results <- stack(bma.e1,bma.e2,bma.e3,bma.e4)
 g.expand<-graphBMA(expand.results, priors)

## visualize
graphView(g.expand)

top.models(expand.results, priors)
end.rcode-->
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Speedup 2: excluding SNPs with low single SNP support</h3>
<div class="outline-text-3" id="text-5-3">
<p>
We can consider an additional way to prune the model space: exclude
SNPs with very limited single SNP support.  In this case, we drop
SNPs that have a 2 log Bayes Factor (versus the null model with no
SNPs) &lt; 2.2, a threshold previous described as "weak support".
</p>

<!--begin.rcode 
## define the list of SNPs to drop
max.bf <- apply(ss1,1,max)
snps.drop <- rownames(ss1)[ max.bf < 2.2 ]
snps.drop
end.rcode-->

<p>
Then we can assess all two SNP models excluding those in snps.drop.  We
will also analyse the complete set of data, so the two approaches can
be compared.  To do this, we
need to prune the snps included in the <code>bma.1</code> object and the <code>data</code> object.
</p>

<!--begin.rcode 
## generate a new set of tags and snpBMAdata object
tags <- tags[!(tags %in% snps.drop)]
data2 <- make.data(X, Y,tags=tags,family="gaussian")

bma.2 <- bma.nsnps(data, nsnps=2)
bma.2d <- bma.nsnps(data2, nsnps=2)
end.rcode-->
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> Excluding unlikely models</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Models with two or more SNPs can be thought of as children of many
parent models.  If a two SNP model contains SNPs A and B, then its
parents are the single SNP models containing either A or B.  Each
parent model has many potential children.  Thus the model space can
be partitioned into generations, with each generation containing a
fixed number of SNPs.  Any two or more SNP model can be reached via
multiple paths in this model space.
</p>

<p>
\cite{madigan94} proposed that where child models had a parent with
greater support than the child, no further "grandchild" models would
be worth considering.  This is quite a broad pruning.  We choose to
implement a variation where the future generation models are excluded
if a child model has a parent model with \(f\)-fold greater support,
and have set the default at \(f=10\).
</p>

<p>
Here, we compare the child and parent models in <code>bma.1</code> and <code>bma.2d</code>
to determine the set of models we will not explore.  One way to
implement this would be to determine all the possible three SNP
models, then delete those that are children of the dropped models.
But a faster way is to drop these models from the <code>bma2</code> object, then
use <code>bma.grow()</code> to automatically fit all the child models of those
which remain.
</p>

<!--begin.rcode BMA3
priors <- prior.binomial(1:10, n=ncol(X), expected=3)

## prune the bma.2d object
bma.2dd <- models.prune(parents=bma.1, children=bma.2d, 
                        prior.parents=priors[1],
                        prior.children=priors[2])

## grow the BMA to a third generation
bma.3dd <- bma.grow(data2, bma.2dd)

## for comparison, without pruning, we could use tagging only...
bma.3 <- bma.nsnps(data, nsnps=3)

## ... or tagging + excluding poorly supported single SNPs
bma.3d <- bma.nsnps(data2, nsnps=3)

## this should be the same as growing from the bma.2d object
bma.3d2 <- bma.grow(data2, bma.2d)

bma.3d
bma.3d2
end.rcode-->
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Automating the analysis</h2>
<div class="outline-text-2" id="text-6">
<p>
There are a lot of steps above.  It's good to understand the detail
of how we approach the problem, but once you understand it, it can be
tedious to run each step.  We have a function, <code>bma.auto()</code>, that
should automate much of this.
</p>

<p>
TODO!!!
</p>

<div class="org-src-container">

<pre class="src src-LATEX">\bibliographystyle{plain}
\bibliography{ProbePosition}
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2013-05-22 Wed</p>
<p class="author">Author: Chris Wallace</p>
<p class="date">Created: 2013-06-10 Mon 17:01</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.2.1 (<a href="http://orgmode.org">Org</a> mode 8.0.3)</p>
<p class="xhtml-validation"><a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a></p>
</div>
</body>
</html>
